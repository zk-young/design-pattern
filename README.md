# design-pattern
#设计模式
#####设计模式的目的:
        1)代码的重用性(即相同功能的代码不用多次编写)
        2)可读性(编程规范性)
        3)可扩展性(即:当需要增加新功能时非常的方便,可维护性)
        4)可靠性(当新增加功能时,对原来的功能没有影响)
        5)时程序呈现高内聚,低耦合的特性 
设计模式包含了面向对象的精髓(继承,封装,多态)
####设计模式常用的七大原则有:
        1.单一接口原则
                一个类应该只负责一项职责(比如dao应该只负责查询一张表)
                 注意事项:
                    降低类的复杂度,一个类只负责一项职责
                    提高可读性,可维护性
                    降低变更引起的风险
                    通常情况下,应当遵守单一职责原则
        2.接口隔离原则
                客户端不应该依赖他不需要的接口,即一个类对另一个类的依赖应该建立在最小的接口上
                对大接口实行拆分.
        3.依赖倒转(倒置)原则
                1)高层模块不应该依赖低层模块,二者都应该依赖其抽象
                2)抽象不应该依赖细节
                3)依赖倒转的思想是面向接口编程
                4)依赖倒转原则是基于这样的设计理念,相对于细节的多变性,抽象
                    的东西稳定的多,以抽象为基础搭建的架构比以细节为架构搭建的架构稳定的多
                    在java中 指的是接口或者抽象类,细节就是具体的实现类
                5)使用接口或者抽象类的目的是制定好规范,而不涉及任何具体的操作,扩展细节的任务交给实现类完成

                三种方式:接口,构造器,set注入
        4.里氏替换原则
                在使用继承时子类中尽量不要重写父类的方法
                继承同一基础类,减少重写(大规模重写父类的时候,应抽取base类同时继承)
        5.开闭原则(ocp)
                是最重要的设计原则 如一个实体类 模块和函数应该对扩展开发,对修改关闭
                当软件需要变化时,尽量通过扩展软件实体的行为来实现变化,而不是修改已经有的代码来实现变化
        6.迪米特法则
                一个对象应该对其他对象保持最少的了解
                类与类关系越密切,耦合度越大
                迪米特法则又叫最少知道原则,即一个类对自己依赖的类知道的越少越好,也就是说对于被依赖的类不管多么复杂,都尽量将
                逻辑封装在类的内部,对外提供public方法 不对外提供任何信息
                只与直接的朋友通信
        7.合成复用原则
####UML类图
    note:对uml进行注释
    Class:表示类
    interface:接口
    Dependency:表示依赖
    Association:表示关联
    Generalization:表示泛化:继承
    Realization:表示实现
    Aggregation:表示聚合:
    composite:组合 
    类图:用于描述类本身的组成和类之间的各种静态关系

    依赖关系:只要在类中用到了对象就是存在依赖关系
    泛化关系:依赖关系的特例----继承
### 设计模式类型
    1)创建型模式:单例模式,抽象工厂模式,原型模式,建造者模式,工厂模式
    2)结构型模式:适配器模式,桥接模式,装饰模式,组合模式,外观模式,享元模式,代理模式
    3)行为型模式:模板模式,命令模式,访问者模式,迭代器模式,观察者模式,中介者模式,备忘录模式,解释器模式(interpreter模式),状态模式,策略模式,责任链模式
    
### 1单例模式
    所谓的单例模式就是采取一定的方法保证在整个系统软件中,对某个类智能存在一个对象实例,并且该类只提供一个取得其对象的方法(静态方法)
    八种方式:
        1)饿汉式(静态常量)
            构造器私有化(防止new)
            累的内部创建对象
            对外提供公有方法
                优缺点说明:  
                    1)优点:这种写法比较简单,就是在类装载的时候就完成实例化 避免了线程同步的问题
                    2)缺点:在类装载的时候完成实例化,没有达到lazy loading 的效果 如果从始至终从未使用过这个实例,就会造成内存浪费
                    结论:这种单例模式可用,可能造成内存浪费.
        2)饿汉式(静态代码块)
                优缺点:
                    1)这种方式将类的实例化的过程放在静态代码块中,也是在类装载的时候,就会执行静态代码块中的代码,初始化类的实例
                    2)这种单例模式可用,但是可能造成内存浪费
        3)懒汉式(线程不安全)
                优缺点:
                    1):起到了懒加载的效果,但是只能在单线程下使用
                    2):如果在多线程下,一个线程进入了(if(instance==null)判断语句块.还未来的及往下执行,另一个线程也通过了这个
                        判断语句,这时候会产生多个实例,所以在多线程环境下不可使用这种方式
                    3)结论:在实际开发中不要使用这种方式
        4)懒汉式(线程安全,同步方法)
                优缺点:
                    1):解决了线程不安全的问题
                    2):效率太低,每个线程在想获得类的实例的时候,执行getinstance()方法都要进行同步,而其实这个方法只执行一次实例化代码就够了
                    3)实际开发不推荐
        5)懒汉式(线程安全,同步代码块)
                改进上述效率问题,但在判断处加关键字并不能保证线程安全 实际开发不使用
        6)双重检查
                优缺点:
                    1):线程安全,延迟加载 ;效率高  
                    2):开发中推荐使用
        7)静态内部类
            1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。
            2) 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化
               时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的
               实例化。
            3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们
               保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
            4) 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高
            5) 结论：推荐使用.
        8)枚举    
            1) 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而
            且还能防止反序列化重新创建新的对象。
            2) 这种方式是Effective Java作者Josh Bloch 提倡的方式
            3) 结论：推荐使用